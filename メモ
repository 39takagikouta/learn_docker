・dockerとは
コンテナ仮想化技術を使って、アプリケーションを開発・配置・実行するための隔離された環境を提供するツール
コンテナとは、パソコンやサーバ上で隔離され、干渉されない環境
ソフトウェアならば何でも入れられる　小さなパソコンが入っているようなもの
どこかのosの上でしか動かせない（ホストos）
この上でdockerが動いて、コンテナを作ったりホストosとの仲介をしたりする
コンテナがないとホストosに干渉しうる　コンテナの中はホストosとは干渉しない　別のバージョンのrubyを入れることができる
macでもwindowsでもほとんど変わらない
imageとdockerファイルで写せる

・dockerイメージとは
イメージには、コンテナに必要なソフトウェア、環境変数、設定などが入っている
コンテナの型　コンテナと別である
特徴　配布とコンテナ環境の再現が可能　変更不可

image作り方
1イメージレジストリ(DockerHubやAWS ECRなど)　2dockerflie
1は誰でも登録できる　マイナーな奴は危険
指定しなければ1からベースイメージがダウンロードされる
コンテナにはstatusがある
docker image pull hoge
tagを指定しなければlatestが勝手にインストールされる
image idでも破棄できる

・imageからコンテナ作成
docker container ls -aでステータスを確認できる
containerをいきなりしたらimageimageもとって来てくれる
削除とか再起動とか停止とかも非常に直感的に行うことができる
旧コマンドと新コマンドがあるから注意　明示的になっている

・dockerコンテナの操作と挙動
bashとは、LinuxやMacなどのUnix系のOSで利用されているシェルの一種
シェルとは、カーネルに翻訳してくれる
カーネル（osのコアの機能を担っているソフトウェア、ファイルを開いたり書き込んだり）を直接触らない　機械語しか話せないから
ターミナルはシェルの窓口
ubuntu Linuxの一種のos 無料の有名なソフトウェア
デフォルトのコマンドはbash

runの際の-itの意味　-iと-tの結合
docker container run ubuntuならば標準入力がターミナルに対してclose
-iでopenにできる
-tはコマンドの見た目をきれいにしてくれている
これらは必ずつけるものと理解してしまって問題ない

コンテナ起動時に実行されるコマンドを変更する
docker image inspect hogeで詳細を確認できる　ここでデフォルトコマンドを確認
docker container run -it ubuntu:20.04の後に実行させたいコマンドを入れたらそれを実行できる

既存のコンテナにコマンドを実行させる方法
upのコンテナに対してはexexを使う　-itをつけるといい
restartをするとバッシュの画面にはならない
runはイメージ名　execはコンテナ名

コンテナに名前をつける
docker container run --name hoge ubuntu

コンテナ整理のためのコマンド
docker container pruneはup以外のコンテナが全部消える
runの時に--rmをつけたらコマンドが実行されたら自動で破棄される コンテナは使い捨てで使うことが多いから、実務でよく使う
upを削除する　rmはupに対しては使えない rm -fをつける

デタッチ度（切り離された）モードとフォアグラウンドモード
前者の場合はコンテナがバックグラウンドで動くようになる　-d（runとexexで使える）
後者は今まで使って来たやつ
どういう時に使う？　bashの場合はコンテナに命令をするもの　だから前者を使ったらやりたかったことができなくなるからほとんどない
あるのは、コンテナにコマンドを実行させ、それをバックグラウンドで常駐させたい時
モードの切替えもできる　docker coutainer attach　コンテナに名前をつける

・dockerfileでカスタムイメージを作成する
実際の業務ではこっちを使うことが多い
自分好みのimageを作るための設計書
dockerhubに存在するイメージの多くは、有名なソフトウェアが入っているイメージが存在するが、最低限の機能しか入っていない
例えばubuntu上でrubyを動かしたいなら、ubuntuのイメージをベースにしてrubyをインストールしないといけない
ベースイメージをダウンロードし、好きなものを入れていくのが基本
コンテナを直接書き直しても意味ない　カスタマイズは可能だが一度起動したコンテナは自分のパソコン上だけのもので、持ち運びはできない
持ち運べるのはimageだけ　これをカスタマイズしないとdockerの意味がない

dockerfileからイメージ作成
docker image build パス
基本の書き方　大文字で命令　それに対してパラメータ

imageに名前とタグをつける
-t hoge:huga

copyで好きなファイルやフォルダをイメージに配置する

ビルドコンテキストとは
docker image build hoge
hogeの部分は厳密にはDockerfileの場所ではなく、ビルドコンテキストのパスを指定する
本コマンドはDockerfileとビルドコンテキストからイメージを作成するコマンド
アーキテクチャは動画参照
クライアント（docker CLI）、rest api、サーバ（dockerデーモン）の三層構造
クライアントとサーバは違う場所にあっても動く（今は全部PCの中にあるが）
だから、dockerデーモンにbuildに必要なものを渡す必要がある　Dockerfileだけでなくコンテキストも
→これがビルドコンテキスト　dockerデーモンに与えるコンテキストのこと
-fでビルドコンテキストとDockerfileの位置を分けることができる
.dockerignoreでビルドコンテキストから除外もできる
これは、例えば秘匿情報のファイルに使う　重いファイルの時とかも

CMDでデフォルトコマンドを設定する
CMD["実行ファイル","パラメータ","パラメータ"]
コンテナ実行時のデフォルトコマンドを設定する
dockerfileで一度しか使えない
複数あれば最後のやつが適用
何も記載がなければfromのやつのデフォルトが適用

読み込み専用のイメージレイヤーが重なってimageになっている
Dockerfileの一行が一レイヤー　詳細は画像参照
イメージの変更差分がレイヤーとして保存される
docker image history idで見れる
一番上でコンテナレイヤーが動く　コンテナ上での変更が保存される　書き込みもできる　ここで作業する
イメージレイヤーの容量を小さくする方法　書き方は具体例参照
レイヤーが少ない方が容量は小さくなる
イメージレイヤーはキャッシュされているので、一度インストールしたものは流用できる
変更に強いのがレイヤーを細かく分けるメリット　入れるものが決まっていない場合は分けた方がいい

環境変数をコンテナ内で設定する
DockerfileにENV hello = "hoge" スペースがなかったら""はいらない
呼び出し方　echo $hello
環境によって挙動を変える際にも使用する

ARGで任意の変数を扱う
ARG 変数名=デフォルト値