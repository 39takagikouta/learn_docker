・dockerとは
コンテナ仮想化技術を使って、アプリケーションを開発・配置・実行するための隔離された環境を提供するツール
コンテナとは、パソコンやサーバ上で隔離され、干渉されない環境
ソフトウェアならば何でも入れられる　小さなパソコンが入っているようなもの
どこかのosの上でしか動かせない（ホストos）
この上でdockerが動いて、コンテナを作ったりホストosとの仲介をしたりする
コンテナがないとホストosに干渉しうる　コンテナの中はホストosとは干渉しない　別のバージョンのrubyを入れることができる
macでもwindowsでもほとんど変わらない
imageとdockerファイルで写せる

・dockerイメージとは
イメージには、コンテナに必要なソフトウェア、環境変数、設定などが入っている
コンテナの型　コンテナと別である
特徴　配布とコンテナ環境の再現が可能　変更不可

image作り方
1イメージレジストリ(DockerHubやAWS ECRなど)　2dockerflie
1は誰でも登録できる　マイナーな奴は危険
指定しなければ1からベースイメージがダウンロードされる
コンテナにはstatusがある
docker image pull hoge
tagを指定しなければlatestが勝手にインストールされる
image idでも破棄できる

・imageからコンテナ作成
docker container ls -aでステータスを確認できる
containerをいきなりしたらimageimageもとって来てくれる
削除とか再起動とか停止とかも非常に直感的に行うことができる
旧コマンドと新コマンドがあるから注意　明示的になっている

・dockerコンテナの操作と挙動
bashとは、LinuxやMacなどのUnix系のOSで利用されているシェルの一種
シェルとは、カーネルに翻訳してくれる
カーネル（osのコアの機能を担っているソフトウェア、ファイルを開いたり書き込んだり）を直接触らない　機械語しか話せないから
ターミナルはシェルの窓口
ubuntu Linuxの一種のos 無料の有名なソフトウェア
デフォルトのコマンドはbash

runの際の-itの意味　-iと-tの結合
docker container run ubuntuならば標準入力がターミナルに対してclose
-iでopenにできる
-tはコマンドの見た目をきれいにしてくれている
これらは必ずつけるものと理解してしまって問題ない

コンテナ起動時に実行されるコマンドを変更する
docker image inspect hogeで詳細を確認できる　ここでデフォルトコマンドを確認
docker container run -it ubuntu:20.04の後に実行させたいコマンドを入れたらそれを実行できる

既存のコンテナにコマンドを実行させる方法
upのコンテナに対してはexexを使う　-itをつけるといい
restartをするとバッシュの画面にはならない
runはイメージ名　execはコンテナ名

コンテナに名前をつける
docker container run --name hoge ubuntu

コンテナ整理のためのコマンド
docker container pruneはup以外のコンテナが全部消える
runの時に--rmをつけたらコマンドが実行されたら自動で破棄される コンテナは使い捨てで使うことが多いから、実務でよく使う
upを削除する　rmはupに対しては使えない rm -fをつける

デタッチ度（切り離された）モードとフォアグラウンドモード
前者の場合はコンテナがバックグラウンドで動くようになる　-d（runとexexで使える）
後者は今まで使って来たやつ
どういう時に使う？　bashの場合はコンテナに命令をするもの　だから前者を使ったらやりたかったことができなくなるからほとんどない
あるのは、コンテナにコマンドを実行させ、それをバックグラウンドで常駐させたい時
モードの切替えもできる　docker coutainer attach　コンテナに名前をつける

・dockerfileでカスタムイメージを作成する
実際の業務ではこっちを使うことが多い
自分好みのimageを作るための設計書
dockerhubに存在するイメージの多くは、有名なソフトウェアが入っているイメージが存在するが、最低限の機能しか入っていない
例えばubuntu上でrubyを動かしたいなら、ubuntuのイメージをベースにしてrubyをインストールしないといけない
ベースイメージをダウンロードし、好きなものを入れていくのが基本
コンテナを直接書き直しても意味ない　カスタマイズは可能だが一度起動したコンテナは自分のパソコン上だけのもので、持ち運びはできない
持ち運べるのはimageだけ　これをカスタマイズしないとdockerの意味がない

dockerfileからイメージ作成
docker image build パス
基本の書き方　大文字で命令　それに対してパラメータ

imageに名前とタグをつける
-t hoge:huga

copyで好きなファイルやフォルダをイメージに配置する

ビルドコンテキストとは
docker image build hoge
hogeの部分は厳密にはDockerfileの場所ではなく、ビルドコンテキストのパスを指定する
本コマンドはDockerfileとビルドコンテキストからイメージを作成するコマンド
アーキテクチャは動画参照
クライアント（docker CLI）、rest api、サーバ（dockerデーモン）の三層構造
クライアントとサーバは違う場所にあっても動く（今は全部PCの中にあるが）
だから、dockerデーモンにbuildに必要なものを渡す必要がある　Dockerfileだけでなくコンテキストも
→これがビルドコンテキスト　dockerデーモンに与えるコンテキストのこと
-fでビルドコンテキストとDockerfileの位置を分けることができる
.dockerignoreでビルドコンテキストから除外もできる
これは、例えば秘匿情報のファイルに使う　重いファイルの時とかも

CMDでデフォルトコマンドを設定する
CMD["実行ファイル","パラメータ","パラメータ"]
コンテナ実行時のデフォルトコマンドを設定する
dockerfileで一度しか使えない
複数あれば最後のやつが適用
何も記載がなければfromのやつのデフォルトが適用

読み込み専用のイメージレイヤーが重なってimageになっている
Dockerfileの一行が一レイヤー　詳細は画像参照
イメージの変更差分がレイヤーとして保存される
docker image history idで見れる
一番上でコンテナレイヤーが動く　コンテナ上での変更が保存される　書き込みもできる　ここで作業する
イメージレイヤーの容量を小さくする方法　書き方は具体例参照
レイヤーが少ない方が容量は小さくなる
イメージレイヤーはキャッシュされているので、一度インストールしたものは流用できる
変更に強いのがレイヤーを細かく分けるメリット　入れるものが決まっていない場合は分けた方がいい

環境変数をコンテナ内で設定する
DockerfileにENV hello = "hoge" スペースがなかったら""はいらない
呼び出し方　echo $hello
環境によって挙動を変える際にも使用する

ARGで任意の変数を扱う
ARG 変数名=デフォルト値
image作成時にDockerfileの中で使える変数を作成することが可能
docker image build --build-arg message="hello message" .
上記のような形でimage作成時に変数に値を入れることができる
FROM ubuntu22:04 AS base
RUN apt update
CMD ["sh","-c","echo Myname is $my_name"]

FROM base AS dev
ENV my_name=TEST

FROM base AS pro
ENV my_name=Bob


両者の使い分け
ARGはイメージ作成時のみ有効であり、ENVはコンテナ上でも使える
コンテナの中で環境変数につき処理を動的に変える時はENV
buildの時にしか使わないならarg　予期しない悪影響を避けるため

作業ディレクトリの変更
WORKDIR ディレクトリパス
RUNやCMDなどが動く場所を指定する際に使用
ディレクトリが存在しないなら作ってくれる　デフォルトは/
ログイン時のディレクトリを指定できる　よく使う

・マルチステージビルド
ステージによって必要なソフトウェアは異なる
同じイメージを使いまわそうとするとイメージサイズが大きくなる
これを使うと、一つのドッカーファイルでステージごとの環境を分離し、必要なイメージだけを作れる
これ多分rubyならいらんから流し見やな

開発環境と本番環境で挙動を分けたい場合、Dockerfileを分けてもいいが、面倒
マルチステージビルドなら一つのドッカーファイルで2つのイメージを作ることができる
docker image build --target dev .
オブジェクト指向みたいやな

・dockerとストレージ
コンテナレイヤーはコンテナが削除されると消える
これを消えないようにする方法　コンテナのデータを永続化
1ボリューム　2バインドマウント

1について
dockerが管理しているボリューム領域がある　各コンテナから接続できる
外付けハードディスクのバックアップのようなもの
各コマンドは動画
マウントポイントとは、ボリューム領域のパス
Macではdockerデスクトップで構築した　火葬でLINUXの環境を構築　それを使ってコンテナ環境を作っている
デスクトップの場合、ドッカーが管理するボリューム領域にホストからアクセスすることはできない
そもそもこれにアクセスするユースケースはないが
docker container run -it -v my-volume:/app1 --name container-1 ubuntu
これでvolumeに接続しながらコンテナを起動する
絶対パスな必要がある　.は使えない

2
ローカルマシンのディレクトリとコンテナのディレクトリを同期（マウント）させる
マウントとはLINUXの用語
docker container run -it -v /Users/takagikouta/learn_docker:/app ubuntu
pwdで絶対パスを取れる　$(pwd)/my-dirとかもいける

違い
前者はホストからアクセスできない
後者はホスト側の環境に依存する
ドッカー側ではデータの永続化の際はvolumeを推奨
ホスト側からデータアクセスが必要でない場合はこっち
データベースのコンテナでは前者をよく使う　データベースのデータには直接アクセスする必要がないから

・コンテナと接続する
ホストとコンテナのポートを紐づける
ポートとは、住所の一つ　IPアドレス（サーバー）とポート番号（サーバー内のアプリ）で構成される
Nginxはhttpサーバー
コンテナの中のアプリにアクセスするには、ホストマシンのポートとコンテナのポートを紐づけないといけない
docker container run -p 3000:80 .
docker container lsでも紐付けを見れる

dockerネットワーク
複数立ち上げるのが当たり前　アプリとデータベースで分けたり
コンテナ同士の通信を簡単にしたり、不要なコンテナ同士の通信を防ぐために隔離する方法
docker network ls
何も設定しなかったら、デフォルトのbridgeというネットワークに入る
複数のコンテナ同士の通信を橋渡しするからbridge
注意点　bridgeはブリッジネットワークの一種
docker network inspect ネットワーク名で詳細を確認できる　入っているコンテナも
docker network create my-net かなり直感的に作れるdocker container run -itd --rm --name my-nginx-2 --network my-net nginx

ネットワーク内でのhttp通信の仕方
一つのイメージをビルドして、それから二つのコンテナを作れる
curlはhttpリクエストを送るために使う

名前解決
ipアドレスを直接取得しなくても、コンテナ名でルーティングされる
起動するたびにIPアドレスは変わるが、名前は変わらない
正、bridgeネットワークでは使えない
docker network rm　ネットワーク名　で削除できる
